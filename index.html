<!DOCTYPE html>
<html lang="en">
  <head>
      <meta charset="utf-8">
      <title>D3 Page Template</title>
      <link type="text/css" href="stylesheet.css" rel="stylesheet">
      <script type="text/javascript" src="https://d3js.org/d3.v4.min.js"></script>

      <style>
          div.tooltip {	
            position: absolute;			
            text-align: center;			
            width: auto;					
            height: auto;					
            padding: 5px;				
            font: 12px sans-serif;		
            background: lightsteelblue;	
            border: 0px;		
            border-radius: 8px;			
            pointer-events: none;			
        }
        .map {
            fill: 'grey';
            border-width: 2px;
            border-color: black
        }
      </style>
  </head>
  <body>
      <h1>San Francisco</h1>
    <script>
        var margin = {top: 20, right: 20, bottom: 30, left: 50}
        var w = 1200 - margin.left - margin.right;
        var h = 600 - margin.top - margin.bottom;
        var padding = 1;
        var wBar = 1100 - margin.left - margin.right;
        var hBar = 200 - margin.top - margin.bottom;
                            
        var hoursLabels = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23];

        var svg = d3.select("body")
                    .append("svg")
                    .attr("width", w)
                    .attr("height", h);

        var svgHourBar = d3.select("body")
                            .append("svg")
                            .attr("width", w)
                            .attr("height", 700);

        var div = d3.select("body")
                    .append("div")	
                    .attr("class", "tooltip")				
                    .style("opacity", 0);

        var projection, brush, circles;

        d3.csv("JustFires.csv", function(data) {
            var coords = [];

            var count = 0;
            data.forEach(d => {
                if (count < 1000) {
                    coords.push({
                        'lon': +d.Longitudes,
                        'lat': +d.Latitudes,
                        'desc': d.Desc,
                        'hour': +d.Hour - 1
                    })
                    count++;
                }
            });

            d3.json("san-francisco.geojson", function(json) {
                createMap(json);
                plotIncidents(coords);
                createFireByHourBarChart(coords);

                brush = d3.brush()
                        .on("brush", brushed);
        
                svg.append("g")
                    .call(brush);
            });
        })

    
        function createMap(json) {
            // https://stackoverflow.com/questions/14492284/center-a-map-in-d3-given-a-geojson-object
            var width  = w;
            var height = 500;

            var center = d3.geoCentroid(json)
            var scale  = 150;
            var offset = [w/2, h/4];

            projection = d3.geoMercator()
                            .center(center)
                            .translate(offset)
                            .scale(scale);

            // create the path
            var path = d3.geoPath().projection(projection);

            // using the path determine the bounds of the current map and use 
            // these to determine better values for the scale and translation
            var bounds  = path.bounds(json);
            var hscale  = scale*width  / (bounds[1][0] - bounds[0][0]);
            var vscale  = scale*height / (bounds[1][1] - bounds[0][1]);
            var scale   = (hscale < vscale) ? hscale : vscale;
            var offset  = [width - (bounds[0][0] + bounds[1][0])/2,
                            height - (bounds[0][1] + bounds[1][1])/2];

            // new projection
            projection = d3.geoMercator()
                            .center(center)
                            .scale(scale)
                            .translate(offset);

            path = path.projection(projection);

            //Bind data and create one path per GeoJSON 
            svg.selectAll("path")
                    .data(json.features)
                    .enter()
                    .append("path")
                    .attr("class", "map")
                    .attr("d", path)
                    .on("mouseover", function(d) {

                        d3.select(this)
                            .style("fill", "grey");

                        // Tooltip
                        div.transition()		
                            .duration(200)		
                            .style("opacity", .9);

                        div.html(d.properties.name)	
                            .style("left", (d3.event.pageX) + "px")		
                            .style("top", (d3.event.pageY - 28) + "px");
                    })
                    .on("mouseout", function(e) {
                        d3.select(this)
                            .style("fill", "black");

                        div.transition()		
                            .duration(500)		
                            .style("opacity", 0);
                    })
                    .on("click", function(d) {
                        console.log("Clicked " + d.properties.name)
                    });
        }

        function plotIncidents(coords) {
            circles = svg.append("g")
                        .selectAll("circle")
                        .data(coords)
                        .enter()
                        .append("circle")
                        .attr("cx", function(d) {
                            return projection([d.lon, d.lat])[0];
                        })
                        .attr("cy", function(d) {
                            return projection([d.lon, d.lat])[1];
                        })
                        .attr("r", 3)
                        .attr("fill", "orange")
                        .attr("class", "non_brushed_circle")
                        .on("mouseover", function(d) {
                            // Tooltip
                            div.transition()		
                                .duration(200)		
                                .style("opacity", .9);

                            div.html("Description: " + d.desc + "</br>" )	
                                .style("left", (d3.event.pageX) + "px")		
                                .style("top", (d3.event.pageY - 28) + "px");
                        })
                        .on("mouseout", function(e) {
                            div.transition()		
                                .duration(500)		
                                .style("opacity", 0);
                        })
        }
    
        var yScaleBar, xScaleBar;


        function createFireByHourBarChart(brushedData) {
            var tempHourData = [];
            for(var i = 0; i < brushedData.length; i++) {
                tempHourData.push(brushedData[i].hour);
            }
            var filteredData = d3.nest()
                                .key(function(d) {
                                    return d;
                                })
                                .entries(tempHourData);

            var ascending = function (a, b) {
                return a.key - b.key
            }

            var sortData = filteredData.sort(ascending);

            yScaleBar = d3.scaleLinear()
                    .domain([0, d3.max(sortData, function(d) {
                        return d.values.length;
                    } )])
                    .rangeRound([hBar,0]);

            xScaleBar = d3.scaleBand()
                        .rangeRound([0,wBar])
                        .padding(0,1)
                        .domain(sortData.map(function(d,i) {
                            return +d.key;
                        }));
            
            //Create X axis
            svgHourBar.append("g")
                .attr("class", "axis-x")
                .attr("transform", "translate(" + margin.left + "," + (hBar+margin.top) + ")")
                .call(d3.axisBottom(xScaleBar));
            
            //Create Y axis
            svgHourBar.append("g")
                .attr("class", "axis-y")
                .attr("transform", "translate(" + margin.left + "," + (margin.top) + ")")
                .call(d3.axisLeft(yScaleBar));

            // X-Label
            svgHourBar.append("text")
                    .attr("class", "legendText")
                    .attr("transform",
                            "translate(" + ((wBar/2)+margin.left) + "," + 
                                        (hBar+35+margin.top) + ")")
                    .text("Hour");

                
            // Y-Label
            svgHourBar.append("text")
                .attr("class", "legendText")
                .attr("transform", "rotate(-90)")
                .attr("y", 0)
                .attr("x", 0 - (hBar / 2) - 70)
                .attr("dy", "1em")
                .text("# of fire incidents"); 


            bars = svgHourBar.append("g")
                    .selectAll("rect1")
                    .data(sortData)
                    .enter()
                    .append("rect")
                    .attr("class", "selData")
                    .attr("transform", "translate(" + margin.left + ","+ margin.top +")")
                    .attr("x", function(d,i) {
                        console.log(+d.key)
                        return xScaleBar(+d.key);
                    })
                    .attr("y", function(d) {                        
                        return yScaleBar(d.values.length);
                    })
                    .attr("width", xScaleBar.bandwidth()-1)
                    .attr("height", function(d){
                        return hBar-yScaleBar(d.values.length);
                    });
        }

        function brushed() {
            if (d3.event.selection != null) {
                // revert circles to initial style
                circles.attr("class", "non_brushed");

                var brush_coords = d3.brushSelection(this);

                // style brushed circles
                circles.filter(function (){

                        var cx = d3.select(this).attr("cx"),
                            cy = d3.select(this).attr("cy");
                        return isBrushed(brush_coords, cx, cy);
                })
                .attr("class", "brushed");

                var d_brushed =  d3.selectAll(".brushed").data();
                if (d_brushed.length > 0) {
                    // clearChart();
                    // createBarChart(d_brushed);
                    updateBarChartValues(d_brushed);
                } else {
                    // clearChart();
                    updateBarChartValues(d_brushed);
                }
            }
        }



        function isBrushed(brush_coords, cx, cy) {
            var x0 = brush_coords[0][0],
                x1 = brush_coords[1][0],
                y0 = brush_coords[0][1],
                y1 = brush_coords[1][1];

            return x0 <= cx && cx <= x1 && y0 <= cy && cy <= y1;
        }



        function updateBarChartValues(newValues) {
            var tempHourData = [];
            for(var i = 0; i < newValues.length; i++) {
                tempHourData.push(newValues[i].hour);
            }
            console.log(newValues)

            var filteredData = d3.nest()
                                .key(function(d) {
                                    return d;
                                })
                                .entries(tempHourData);

            console.log(filteredData)

            var ascending = function (a, b) {
                return a.key - b.key
            }

            var sortData = filteredData.sort(ascending);

            var data = [];

            for(var i = 0; i < hoursLabels.length; i++) {
                data.push({
                    'hour': "" + (i),
                    'values': []
                })
            }

            console.log(data)

            sortData.forEach( d => {
                var index = d.key;
                data[index] = d;
            })

            console.log(sortData)

            sortData = data;

            yScaleBar = d3.scaleLinear()
                    .domain([0, d3.max(sortData, function(d) {
                        return d.values.length;
                    } )])
                    .rangeRound([hBar,0]);

            svgHourBar.selectAll("g.axis-y")
                    .call(d3.axisLeft(yScaleBar));

            svgHourBar.selectAll("rect")
                    .data(sortData)
                    .transition()
                    .duration(250)
                    .ease(d3.easeLinear)
                    .attr("class","selData")
                    .attr("transform","translate(" + margin.left + ","+ margin.top +")")
                    .attr("x",function(d,i) {
                        return xScaleBar(+d.key);
                    })
                    .attr("y",function(d) {                    
                        return yScaleBar(d.values.length);
                    })
                    .attr("width",xScaleBar.bandwidth()-1)
                    .attr("height",function(d){
                        return hBar-yScaleBar(d.values.length);
                    })
                    .attr("fill","grey");
        }

    </script>  
  </body>
</html>
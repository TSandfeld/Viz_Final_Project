<!DOCTYPE html>
<html lang="en">
  <head>
      <meta charset="utf-8">
      <title>D3 Page Template</title>

      <!--- LEAFLET !-->
      <link rel="stylesheet" href="https://unpkg.com/leaflet@1.3.1/dist/leaflet.css"
      integrity="sha512-Rksm5RenBEKSKFjgI3a41vrjkw4EVPlJ3+OiI65vTjIdo9brlAacEuKOiQ5OFh7cOI1bkDwLqdLw3Zg0cRJAAQ=="
      crossorigin=""/>
       <!-- Make sure you put this AFTER Leaflet's CSS -->
      <script src="https://unpkg.com/leaflet@1.3.1/dist/leaflet.js"
      integrity="sha512-/Nsx9X4HebavoBvEBuyp3I7od5tA0UzAxs+j83KgC8PU0kgB4XiK4Lfe4y4cgBtaRJQEIFCW+oC506aPT2L1zw=="
      crossorigin=""></script>

      <link type="text/css" href="stylesheet.css" rel="stylesheet">
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
      <script type="text/javascript" src="https://d3js.org/d3.v4.min.js"></script>

      <style>
        h1.title, h1.title-loader {
            font-family: 'Gill Sans', 'Gill Sans MT', Calibri, 'Trebuchet MS', sans-serif;
            font-size: 48px;
            text-align: center;
        }

        text.legendText {
            font-family: 'Gill Sans', 'Gill Sans MT', Calibri, 'Trebuchet MS', sans-serif;
        }

        text.hourBarTitle, text.violationBarTitle {
            font-family: 'Gill Sans', 'Gill Sans MT', Calibri, 'Trebuchet MS', sans-serif;
            font-size: 20px;
        }

        div.tooltip {	
            position: absolute;			
            text-align: center;			
            width: auto;					
            height: auto;					
            padding: 5px;				
            font: 12px sans-serif;		
            background: lightsteelblue;	
            border: 0px;		
            border-radius: 8px;			
            pointer-events: none;	
            z-index: 1002;		
        }

        div.container {
            height: 100px;
            width: 1000px;

            bottom: 0;
            top: 0;
            left: 0;
            right: 0;

            margin: auto;
        }

        rect.selection {
            z-index: 1001;
        }

        p.reset {
            height: 20px;
            width: 80px;
            text-align: center;
            border-style: solid;
            border-width: 1px;
            border-color: black;
            cursor: pointer;
        }

        p.brødtekst {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            opacity: 0;
        }

        #mapid { 
            height: 180px; 
        }
      </style>
  </head>
  <body>
      <h1 class="title-loader">
            <p>Loading</p>
            <i class="fa fa-refresh fa-spin" style="font-size:96px"></i>
      </h1>
      <h1 class="title" style="opacity: 0;">
          San Francisco
      </h1>

      <div class="container">
          <p class="brødtekst">
            The city of San Fransisco is the home of a lot of fiery incidents!
          </p>
          <p class="brødtekst">
            <i>(Click on a area to view the data in that district, or use the brush on the full map.)</i>
          </p>

          <div id="mapid"></div>
      </div>
    <script>
        var mymap = L.map('mapid').setView([51.505, -0.09], 13);
        L.tileLayer('https://api.tiles.mapbox.com/v4/{id}/{z}/{x}/{y}.png?access_token=pk.eyJ1IjoidHNhbmRmZWxkIiwiYSI6ImNqZ3FqeXhtdzAzYmgyd24xZnNlZGVpZmUifQ.MPuraDT9NR882bcXSXDqEA', {
            attribution: 'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, <a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery © <a href="http://mapbox.com">Mapbox</a>',
            maxZoom: 18,
            id: 'mapbox.streets',
            accessToken: 'your.mapbox.access.token'
        }).addTo(mymap);

        function removeLoader() {
            d3.select("h1.title-loader").remove();
        }

        function showTitleAndText() {
            d3.select("h1.title").style("opacity", 1);
            d3.selectAll("p.brødtekst").style("opacity", 1);

            d3.select("div.container")
                    .attr("height", h);
        }

        var margin = {top: 20, right: 20, bottom: 30, left: 50}
        var w = 1400 - margin.left - margin.right;
        var h = 700 - margin.top - margin.bottom;
        var padding = 1;
        var wBar = 500 - margin.left - margin.right;
        var hBar = 200 - margin.top - margin.bottom;
                            
        var hoursLabels = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23];
        var violationTypes = [];

        // Reset button
        d3.select("div.container")
            .append("p")
            .attr("class", "reset")
            .style("opacity", 0)
            .text("Reset map")
            .on("click", function() {
                resetMap();
                d3.select(this)
                    .transition()
                    .duration(500)
                    .style("opacity", 0)
            });

        var svg = d3.select("div.container")
                    .append("svg")
                    .attr("width", w)
                    .attr("height", h)
                    .append("g")
                    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

        var svgHourBar = d3.select("div.container")
                            .append("svg")
                            .attr("width", w)
                            .attr("height", hBar + 100);

        var div = d3.select("body")
                    .append("div")	
                    .attr("class", "tooltip")				
                    .style("opacity", 0);

        var projection, path, mapCenter, mapScale, mapOffset, brush, circles;
        var zoomMultiplier = 3;
        var circleRadius = 1.5;

        var districtDict = {}; // Key: District name, Value: CSV data
        var circleDict = {}; // Key: District name, Value: <circle> elements

        var yearLimit = 2017;

        d3.csv("JustFires.csv", function(data) {
            var coords = [];

            var count = 0;
            data.forEach(d => {

                if (count < 100000) {
                    var date = d["Incident Date"]
                    var year = +date.substring(date.length - 4, date.length)
                    if (year >= yearLimit) {
                        let dataRow = {
                            'lon': +(d.Longitudes.slice(0,-1)),
                            'lat': +d.Latitudes,
                            'desc': d.Desc,
                            'hour': +d.Hour - 1,
                            'date': d["Incident Date"],
                            'district': d["Neighborhood  District"],
                            'index': d.Index,
                            'type': 'incident'
                        };
                        coords.push(dataRow);

                        var arr = (districtDict[dataRow.district] == null) ? [] : districtDict[dataRow.district];
                        arr.push(dataRow);
                        districtDict[dataRow.district] = arr;

                        count++;
                    }

                }
            });
            
            count = 0;
            d3.csv("New_Violations.csv", function(data) {
                data.forEach(d => {
                    if (count < 100000) {
                        var date = d["Violation Date"]
                        var year = +date.substring(date.length - 4, date.length)

                        if(year >= yearLimit) {
                            let dataRow = {
                                'lon': +d.Longitudes,
                                'lat': +d.Latitudes,
                                'desc': d["Violation Item Description"],
                                'date': d["Violation Date"],
                                'district': d["Neighborhood District"],
                                'violation': d["Violation Item"],
                                'index': d.Index,
                                'type': 'violation'
                            };
                            coords.push(dataRow);

                            var arr = (districtDict[dataRow.district] == null) ? [] : districtDict[dataRow.district];
                            arr.push(dataRow);
                            districtDict[dataRow.district] = arr;
                            
                            count++;
                        }
                    }
                })

                d3.json("san-francisco.geojson", function(json) {
                    createBrush();
                    createMap(json);
                    plotIncidents(coords);
                    createFireByHourBarChart(coords);
                    createViolationTypeBarChart(coords);

                    removeLoader();
                    showTitleAndText();
                });
            })

            
        })

        function createBrush() {
            brush = d3.brush()
                    .on("brush", brushed);
        
            svg.append("g")
                .attr("class", "brush")
                .call(brush)
                .selectAll("rect")
                .attr("height", h);
        }

        function createMap(json) {
            svg.append("defs")
                .append("clipPath")
                .attr("id", "clip")
                .append("rect")
                .attr("width", w)
                .attr("height", h + 20)

            // https://stackoverflow.com/questions/14492284/center-a-map-in-d3-given-a-geojson-object
            var width  = w-200;
            var height = 600;

            var center = d3.geoCentroid(json)
            mapCenter = center;

            var scale  = 150;
            var offset = [w/2, h/3];

            projection = d3.geoMercator()
                            .center(center)
                            .translate(offset)
                            .scale(scale);

            // create the path
            path = d3.geoPath().projection(projection);

            // using the path determine the bounds of the current map and use 
            // these to determine better values for the scale and translation
            var bounds  = path.bounds(json);
            var hscale  = scale*width  / (bounds[1][0] - bounds[0][0]);
            var vscale  = scale*height / (bounds[1][1] - bounds[0][1]);
            var scale   = (hscale < vscale) ? hscale : vscale;
            var offset  = [width - (bounds[0][0] + bounds[1][0])/2,
                            height - (bounds[0][1] + bounds[1][1])/2];

            mapOffset = offset;

            // new projection
            projection = d3.geoMercator()
                            .center(center)
                            .scale(scale)
                            .translate(offset);

            path = path.projection(projection);

            mapScale = scale;
            var zoomScale = scale * zoomMultiplier;

            //Bind data and create one path per GeoJSON 
            svg.selectAll("path")
                    .data(json.features)
                    .enter()
                    .append("path")
                    .attr("class", "map")
                    .attr("clip-path", "url(#clip)")
                    .attr("d", path)
                    .on("mouseover", function(d) {
                        d3.select(this)
                            .style("fill", "lightgrey");

                        // Tooltip
                        div.transition()		
                            .duration(200)		
                            .style("opacity", .9);

                        div.html(d.properties.name)	
                            .style("left", (d3.event.pageX) + "px")		
                            .style("top", (d3.event.pageY - 28) + "px");
                    })
                    .on("mouseout", function(e) {
                        d3.select(this)
                            .style("fill", "transparent");

                        div.transition()		
                            .duration(500)		
                            .style("opacity", 0);
                    })
                    .on("click", function(d) {
                        let districtName = d.properties.name;
                        console.log("Clicked " + districtName)
                        
                        projection = d3.geoMercator()
                                        .center(d3.geoCentroid(d))
                                        .scale(zoomScale)
                                        .translate(mapOffset);

                        path = path.projection(projection);

                        // Remove brush
                        d3.select("rect.overlay")
                            .attr("height", 0);

                        // Zoom into map area
                        d3.selectAll("path")
                            .attr("d", path);
                            // .transition()
                            // .duration(500)


                        // Show reset button
                        d3.select("p.reset")
                            .style("opacity",1);
                            // .transition()
                            // .duration(500)

                        // Update title label
                        d3.select("text.hourBarTitle")
                            .text(districtName);

                        d3.select("text.violationBarTitle")
                            .text(districtName);

                        // Update hour chart with fires from this district
                        var districtData = districtDict[districtName];
                        console.log(districtData)
                        updateHourBarChartValues(districtData);
                        updateViolationTypeBarChartValues(districtData);

                        // Move circles correspondly
                        updateCirclePositions(districtName,zoomMultiplier);

                    })
                    .style("z-index", 1000)
                    .style("stroke-width", "1px")
                    .style("stroke", "black")
                    .style("fill", "transparent");
        }

        function resetMap() {
            projection = d3.geoMercator()
                            .center(mapCenter)
                            .scale(mapScale)
                            .translate(mapOffset);

            // Reset brush
            d3.select("rect.overlay")
                .attr("height", h);

            path = path.projection(projection);

            d3.selectAll("path")
                .attr("d", path);

            updateCirclePositions('all', 1);

            // Update title
            d3.select("text.hourBarTitle")
                .text("All districts");
            
            d3.select("text.violationBarTitle")
                .text("All districts");

            // Update hourChart with all data
            circleData = d3.selectAll("circle").data();
            updateHourBarChartValues(circleData);
            updateViolationTypeBarChartValues(circleData);
        }

        function plotIncidents(coords) {
            circles = svg.append("g")
                        .attr("class", "hiddenPoints")
                        .selectAll(".point")
                        .data(coords)
                        .enter()
                        .append("circle")
                        .attr("clip-path", "url(#clip)")
                        .attr("cx", function(d) {
                            return projection([d.lon, d.lat])[0];
                        })
                        .attr("cy", function(d) {
                            return projection([d.lon, d.lat])[1];
                        })
                        .attr("r", circleRadius)
                        .attr("fill", function(d) {
                            if(d.type == 'violation') {
                                return "orange";
                            } else return "red";
                        })
                        .attr("opacity", 0)
                        .attr("class", "non_brushed_circle");

            let districtNames = Object.keys(districtDict);
            districtNames.forEach(d => {
                let districtClass = "district" + d.replace(/\s/g, '').replace(/\//g, '');
                var circleData = svg.append("g")
                            .attr("class", districtClass)
                            .selectAll(".point")
                            .data(districtDict[d])
                            .enter()
                            .append("circle")
                            .attr("clip-path", "url(#clip)")
                            .attr("cx", function(d) {
                                return projection([d.lon, d.lat])[0];
                            })
                            .attr("cy", function(d) {
                                return projection([d.lon, d.lat])[1];
                            })
                            .attr("r", circleRadius)
                            .attr("fill", function(d) {
                                if(d.type == 'violation') {
                                    return "orange";
                                } else return "red";
                            })
                            .attr("name", "hidden")
                            .attr("opacity",1)
                            .on("mouseover", function(d) {
                                // Tooltip
                                if (d3.select("g." + districtClass).attr("opacity") == 1) {
                                    div.transition()		
                                        .duration(200)		
                                        .style("opacity", .9);

                                    div.html("<b>Description:</b></br> " + d.desc)	
                                        .style("left", (d3.event.pageX) + "px")		
                                        .style("top", (d3.event.pageY - 28) + "px");
                                }
                            })
                            .on("mouseout", function(e) {
                                div.transition()		
                                    .duration(500)		
                                    .style("opacity", 0);
                            })
                
                circleDict[d] = circleData;
            })
        }

        function updateCirclePositions(districtName,radius) {
            if (districtName == 'all') {
                var districtNames = Object.keys(circleDict);

                // Set opacity = 1 for all districts
                districtNames.forEach(d => {
                    // Finds circles that was maximized and minimizes them.
                    if ( d3.selectAll("g.district" + d.replace(/\s/g, '').replace(/\//g, ''))
                            .attr("name") == "shown") {
                        var selectedCircles = circleDict[d];

                        selectedCircles.attr("cx", function(d) {
                            return projection([d.lon, d.lat])[0];
                        })
                        .attr("cy", function(d) {
                            return projection([d.lon, d.lat])[1];
                        })
                        .attr("r", circleRadius*radius);
                    }

                    // Sets opacity
                    d3.selectAll("g.district" + d.replace(/\s/g, '').replace(/\//g, ''))
                    .attr("opacity", 1);
                })

                return;
            }

            d3.selectAll("g.district" + districtName.replace(/\s/g, '').replace(/\//g, ''))
                .attr("name", "shown")
                .attr("opacity", 1);

            var selectedCircles = circleDict[districtName];
            // .transition()
            // .duration(500)
            selectedCircles
            .attr("cx", function(d) {
                return projection([d.lon, d.lat])[0];
            })
            .attr("cy", function(d) {
                return projection([d.lon, d.lat])[1];
            })
            .attr("r", circleRadius*radius);

            var districtNames = Object.keys(circleDict);
            districtNames.forEach(d => {
                if (d != districtName) {
                    d3.selectAll("g.district" + d.replace(/\s/g, '').replace(/\//g, ''))
                    .attr("opacity", 0);
                }
            })
        }
    
        var yScaleBar, xScaleBar;
        const yPaddingForTitle = 30; // To make room for title
        const extraPadding = 100;

        function createFireByHourBarChart(brushedData) {
            var tempHourData = [];
            for(var i = 0; i < brushedData.length; i++) {
                if(brushedData[i].type == 'incident') {
                    tempHourData.push(brushedData[i].hour);
                }
            }
            var filteredData = d3.nest()
                                .key(function(d) {
                                    return d;
                                })
                                .entries(tempHourData);

            var ascending = function (a, b) {
                return a.key - b.key
            }

            var sortData = filteredData.sort(ascending);

            yScaleBar = d3.scaleLinear()
                    .domain([0, d3.max(sortData, function(d) {
                        return d.values.length;
                    } )])
                    .rangeRound([hBar,0]);

            xScaleBar = d3.scaleBand()
                        .rangeRound([0,wBar])
                        .padding(0,1)
                        .domain(sortData.map(function(d,i) {
                            return +d.key;
                        }));
            
            //Create X axis
            svgHourBar.append("g")
                .attr("class", "axis-x")
                .attr("transform", "translate(" + margin.left + "," + (hBar+margin.top+yPaddingForTitle) + ")")
                .call(d3.axisBottom(xScaleBar));
            
            //Create Y axis
            svgHourBar.append("g")
                .attr("class", "axis-y")
                .attr("transform", "translate(" + margin.left + "," + (margin.top+yPaddingForTitle) + ")")
                .call(d3.axisLeft(yScaleBar));

            // Title label
            svgHourBar.append("text")
                        .attr("class", "hourBarTitle")
                        .attr("x", 0 + wBar/2 + 20)
                        .attr("y", 10)
                        .attr("dy", "1em")
                        .text("All districts");

            // X-Label
            svgHourBar.append("text")
                    .attr("class", "legendText")
                    .attr("transform",
                            "translate(" + ((wBar/2)+margin.left/2) + "," + 
                                        (hBar+35+margin.top+yPaddingForTitle) + ")")
                    .text("Hour of day");

            // Y-Label
            svgHourBar.append("text")
                .attr("class", "legendText")
                .attr("transform", "rotate(-90)")
                .attr("y", 0)
                .attr("x", 0 - (hBar / 2) - 70 - yPaddingForTitle)
                .attr("dy", "1em")
                .text("# of fire incidents"); 


            bars = svgHourBar.append("g")
                    .selectAll("rect1")
                    .data(sortData)
                    .enter()
                    .append("rect")
                    .attr("class", "selData")
                    .attr("transform", "translate(" + margin.left + ","+ margin.top +")")
                    .attr("x", function(d,i) {
                        return xScaleBar(+d.key);
                    })
                    .attr("y", function(d) {                        
                        return yScaleBar(d.values.length) + yPaddingForTitle;
                    })
                    .attr("width", xScaleBar.bandwidth()-1)
                    .attr("height", function(d){
                        return hBar-yScaleBar(d.values.length);
                    })
                    .on("mouseover", function(d){
                        d3.select(this)
                            .attr("fill","grey");

                        // Tooltip
                        div.transition()		
                            .duration(200)		
                            .style("opacity", .9);

                        div.html(d.values.length)	
                            .style("left", (d3.event.pageX) + "px")		
                            .style("top", (d3.event.pageY - 28) + "px");
                    })
                    .on("mouseout", function(d) {
                        d3.select(this)
                            .attr("fill", "black");

                        div.transition()		
                            .duration(500)		
                            .style("opacity", 0);
                    });
        }

        var yScaleViolationBar, xScaleViolationBar;
        var distanceFromHourChart = 550;

        var explainerTexts = {
            'REC': "Reviews and certification of records such as emergency plans,</br> test and maintenance documentation, fire drills, etc.",
            'SPR': "Obstruction of sprinklers and failure of maintenance, service,</br> certifications and replacement/installation of parts.",
            'ALR': "Failure of alarm system maintenance",
            'EXT': "Extinguisher requiring service, maintenance or not present.",
            'DOR': "Violation regarding blocking doors, latches, chutes and self-closers.",
            'EXI': "Blocked exits, fire escapes.",
            'STO': "Storage - misplaced combustibles, gas and eletric meters, ceiling clearance.",
            'ELE': "Electrical violations - extension cords, hazards, workspace clearance, etc.",
            'ILL': "Illumination - repair of lighting, missing exit signs.",
            'SIG': "Maintenance/Missing signs - address numbers, evacuation plans.",
            'PER': "Missing fire permit.",
            'SFC': "Breach of San Fransisco Fire Code.",
            'PEN': "Violations regard walls, ceilings, chutes and fire ratings.",
            'COM': "Fire command center features",
            'KEY': "Keys provided by fire marshall. Removed lock boxes.",
            'HAZ': "Hazards - misplaced gas cylinders and flammable liquids.</br> Missing identification signs.",
            'STD': "Standpipes - obstructions, maintenance, missing parts.",
            '999': "Other violations",
        }

        function createViolationTypeBarChart(data) {
            violationTypes = Object.keys(explainerTexts);

            var tempData = [];
            for(var i = 0; i < data.length; i++) {
                if(data[i].type == 'violation') {
                    tempData.push(data[i].violation);
                }
            }

            var filteredData = d3.nest()
                                .key(function(d) {
                                    return d;
                                })
                                .entries(tempData);

            var descending = function (a, b) {
                return b.values.length - a.values.length
            }

            var sortData = filteredData.sort(descending);

            console.log(sortData)

            yScaleViolationBar = d3.scaleLinear()
                    .domain([0, d3.max(sortData, function(d) {
                        return d.values.length;
                    } )])
                    .rangeRound([hBar,0]);

            xScaleViolationBar = d3.scaleBand()
                        .rangeRound([0,wBar])
                        .padding(0,1)
                        .domain(sortData.map(function(d,i) {
                            return d.key;
                        }));
            
            //Create X axis
            svgHourBar.append("g")
                .attr("class", "axis-x")
                .attr("transform", "translate(" + (distanceFromHourChart+margin.left) + "," + (hBar+margin.top+yPaddingForTitle) + ")")
                .call(d3.axisBottom(xScaleViolationBar));
            
            //Create Y axis
            svgHourBar.append("g")
                .attr("class", "axis-y-vio")
                .attr("transform", "translate(" + (distanceFromHourChart+margin.left) + "," + (margin.top+yPaddingForTitle) + ")")
                .call(d3.axisLeft(yScaleViolationBar));

            // Title label
            svgHourBar.append("text")
                        .attr("class", "violationBarTitle")
                        .attr("x", distanceFromHourChart + wBar/2 + 20)
                        .attr("y", 10)
                        .attr("dy", "1em")
                        .text("All districts");

            // X-Label
            svgHourBar.append("text")
                    .attr("class", "legendText")
                    .attr("transform",
                            "translate(" + (distanceFromHourChart+(wBar/2)+margin.left/2 - 10) + "," + 
                                        (hBar+35+margin.top+yPaddingForTitle) + ")")
                    .text("Type of violation");

            // Y-Label
            svgHourBar.append("text")
                .attr("class", "legendText")
                .attr("transform", "rotate(-90)")
                .attr("y", 0 + distanceFromHourChart - 5)
                .attr("x", 0 - (hBar / 2) - 70 - yPaddingForTitle) 
                .attr("dy", "1em")
                .text("# of violations"); 


            bars = svgHourBar.append("g")
                    .selectAll("rect1")
                    .data(sortData)
                    .enter()
                    .append("rect")
                    .attr("class", "vioData")
                    .attr("transform", "translate(" + (distanceFromHourChart+margin.left) + ","+ margin.top +")")
                    .attr("x", function(d,i) {
                        return xScaleViolationBar(d.key);
                    })
                    .attr("y", function(d) {                        
                        return yScaleViolationBar(d.values.length) + yPaddingForTitle;
                    })
                    .attr("width", xScaleViolationBar.bandwidth()-1)
                    .attr("height", function(d){
                        return hBar-yScaleViolationBar(d.values.length);
                    })
                    .on("mouseover", function(d) {
                        d3.select(this)
                            .attr("fill", "grey");

                        // Tooltip
                        div.transition()		
                            .duration(200)		
                            .style("opacity", .9);

                        div.html("<b>" + d.key + "</b></br>" + explainerTexts[d.key])	
                            .style("left", (d3.event.pageX) + "px")		
                            .style("top", (d3.event.pageY - 28) + "px");
                    })
                    .on("mouseout", function(d) {
                        d3.select(this)
                            .attr("fill", "black");

                        div.transition()		
                            .duration(500)		
                            .style("opacity", 0);
                    });
        }

        function brushed() {
            if (d3.event.selection != null) {
                // revert circles to initial style
                circles.attr("class", "non_brushed");

                var brush_coords = d3.brushSelection(this);

                // var districtNames = Object.keys(circleDict);
                // districtNames.forEach(d => {
                //     let circleData = circleDict[d];
                //     let districtClass = "district" + d.replace(/\s/g, '').replace(/\//g, '');

                //     circleData.filter(function (){
                //         var cx = d3.select(this).attr("cx"),
                //             cy = d3.select(this).attr("cy");
                //         return isBrushed(brush_coords, cx, cy);
                //     })
                //     .attr("class", "brushed");
                // })
                // style brushed circles
                circles.filter(function (){
                        var cx = d3.select(this).attr("cx"),
                            cy = d3.select(this).attr("cy");
                        return isBrushed(brush_coords, cx, cy);
                })
                .attr("class", "brushed");

                var d_brushed =  d3.selectAll(".brushed").data();
                if (d_brushed.length > 0) {
                    // clearChart();
                    // createBarChart(d_brushed);
                    updateHourBarChartValues(d_brushed);
                    updateViolationTypeBarChartValues(d_brushed);
                } else {
                    // clearChart();
                    updateHourBarChartValues(d_brushed);
                    updateViolationTypeBarChartValues(d_brushed);
                }
            }
        }

        function isBrushed(brush_coords, cx, cy) {
            var x0 = brush_coords[0][0],
                x1 = brush_coords[1][0],
                y0 = brush_coords[0][1],
                y1 = brush_coords[1][1];

            return x0 <= cx && cx <= x1 && y0 <= cy && cy <= y1;
        }

        function updateViolationTypeBarChartValues(newValues) {
            var tempHourData = [];
            for(var i = 0; i < newValues.length; i++) {
                //Bar chart is only for incidents, not violations. 
                if(newValues[i].type == 'violation') {
                    tempHourData.push(newValues[i].violation);
                }
            }

            var filteredData = d3.nest()
                                .key(function(d) {
                                    return d;
                                })
                                .entries(tempHourData);

            var descending = function (a, b) {
                return b.values.length - a.values.length
            }

            var sortData = filteredData.sort(descending);

            var dataKeys = [];
            sortData.forEach(d => {
                dataKeys.push(d.key)
            })

            var data = [];
            violationTypes.forEach(d => {
                if (dataKeys.includes(d)) {
                    sortData.forEach(o => {
                        if (o.key == d) {
                            data.push(o);
                        }
                    })
                } else {
                    data.push({
                        key: d,
                        values: []
                    })
                }
            })

            sortData = data;

            yScaleViolationBar = d3.scaleLinear()
                                    .domain([0, d3.max(sortData, function(d) {
                                        return d.values.length;
                                    } )])
                                    .rangeRound([hBar,0]);

            svgHourBar.selectAll("g.axis-y-vio")
                    .call(d3.axisLeft(yScaleViolationBar));

            svgHourBar.selectAll("rect.vioData")
                    .data(sortData)
                    .transition()
                    .duration(250)
                    .ease(d3.easeLinear)
                    .attr("class","vioData")
                    .attr("transform", "translate(" + (distanceFromHourChart+margin.left) + ","+ margin.top +")")
                    .attr("x",function(d,i) {
                        return xScaleViolationBar(d.key);
                    })
                    .attr("y",function(d) {                    
                        return yScaleViolationBar(d.values.length) + yPaddingForTitle;
                    })
                    .attr("width",xScaleViolationBar.bandwidth()-1)
                    .attr("height",function(d){
                        return hBar-yScaleViolationBar(d.values.length);
                    })
                    .attr("fill","black");
        }

        function updateHourBarChartValues(newValues) {
            var tempHourData = [];
            for(var i = 0; i < newValues.length; i++) {
                //Bar chart is only for incidents, not violations. 
                if(newValues[i].type == 'incident') {
                    tempHourData.push(newValues[i].hour);
                }
            }

            var filteredData = d3.nest()
                                .key(function(d) {
                                    return d;
                                })
                                .entries(tempHourData);

            var ascending = function (a, b) {
                return a.key - b.key
            }

            var sortData = filteredData.sort(ascending);

            var data = [];
            for(var i = 0; i < hoursLabels.length; i++) {
                data.push({
                    'hour': "" + (i),
                    'values': []
                })
            }

            // console.log(data)

            sortData.forEach( d => {
                var index = d.key;
                data[index] = d;
            })

            // console.log(sortData)

            sortData = data;

            yScaleBar = d3.scaleLinear()
                    .domain([0, d3.max(sortData, function(d) {
                        return d.values.length;
                    } )])
                    .rangeRound([hBar,0]);

            svgHourBar.selectAll("g.axis-y")
                    .call(d3.axisLeft(yScaleBar));

            svgHourBar.selectAll("rect.selData")
                    .data(sortData)
                    .transition()
                    .duration(250)
                    .ease(d3.easeLinear)
                    .attr("class","selData")
                    .attr("transform","translate(" + margin.left + ","+ margin.top +")")
                    .attr("x",function(d,i) {
                        return xScaleBar(+d.key);
                    })
                    .attr("y",function(d) {                    
                        return yScaleBar(d.values.length) + yPaddingForTitle;
                    })
                    .attr("width",xScaleBar.bandwidth()-1)
                    .attr("height",function(d){
                        return hBar-yScaleBar(d.values.length);
                    })
                    .attr("fill","black");
        }

    </script>  
  </body>
</html>
<!DOCTYPE html>
<html lang="en">
  <head>
      <meta charset="utf-8">
      <title>D3 Page Template</title>
      <link type="text/css" href="stylesheet.css" rel="stylesheet">
      <script type="text/javascript" src="https://d3js.org/d3.v4.min.js"></script>

      <style>
        h1.title {
            font-family: 'Gill Sans', 'Gill Sans MT', Calibri, 'Trebuchet MS', sans-serif;
            font-size: 48px;
            text-align: center;
        }

        text.legendText {
            font-family: 'Gill Sans', 'Gill Sans MT', Calibri, 'Trebuchet MS', sans-serif;
        }

        text.hourBarTitle {
            font-family: 'Gill Sans', 'Gill Sans MT', Calibri, 'Trebuchet MS', sans-serif;
            font-size: 20px;
        }

        div.tooltip {	
            position: absolute;			
            text-align: center;			
            width: auto;					
            height: auto;					
            padding: 5px;				
            font: 12px sans-serif;		
            background: lightsteelblue;	
            border: 0px;		
            border-radius: 8px;			
            pointer-events: none;	
            z-index: 1002;		
        }

        div.container {
            height: 1000px;
            width: 1000px;

            bottom: 0;
            top: 0;
            left: 0;
            right: 0;

            margin: auto;
        }

        rect.selection {
            z-index: 1001;
        }

        p.reset {
            height: 20px;
            width: 80px;
            text-align: center;
            border-style: solid;
            border-width: 1px;
            border-color: black;
            cursor: pointer;
        }
      </style>
  </head>
  <body>
      <h1 class="title">San Francisco</h1>
      <div class="container"></div>
    <script>
        var margin = {top: 20, right: 20, bottom: 30, left: 50}
        var w = 900 - margin.left - margin.right;
        var h = 600 - margin.top - margin.bottom;
        var padding = 1;
        var wBar = 500 - margin.left - margin.right;
        var hBar = 200 - margin.top - margin.bottom;
                            
        var hoursLabels = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23];

        // Reset button
        d3.select("div.container")
            .append("p")
            .attr("class", "reset")
            .style("opacity", 0)
            .text("Reset map")
            .on("click", function() {
                resetMap();
                d3.select(this)
                    .transition()
                    .duration(500)
                    .style("opacity", 0)
            });

        var svg = d3.select("div.container")
                    .append("svg")
                    .attr("width", w)
                    .attr("height", h)
                    .append("g")
                    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

        var svgHourBar = d3.select("div.container")
                            .append("svg")
                            .attr("width", w)
                            .attr("height", 700);

        var div = d3.select("body")
                    .append("div")	
                    .attr("class", "tooltip")				
                    .style("opacity", 0);

        var projection, path, mapCenter, mapScale, mapOffset, brush, circles;
        var zoomMultiplier = 1.8;

        d3.csv("JustFires.csv", function(data) {
            var coords = [];

            var count = 0;
            data.forEach(d => {

                if (count < 100000) {
                    var date = d["Incident Date"]
                    var year = +date.substring(date.length - 4, date.length)
                    
                    if (year >= 2017) {
                        coords.push({
                            'lon': +(d.Longitudes.slice(0,-1)),
                            'lat': +d.Latitudes,
                            'desc': d.Desc,
                            'hour': +d.Hour - 1,
                            'date': d["Incident Date"],
                            'district': d["Neighborhood  District"],
                            'index': d.Index
                        })
                        count++;
                    }

                }
            });

            d3.json("san-francisco.geojson", function(json) {
                createBrush();
                createMap(json);
                plotIncidents(coords);
                createFireByHourBarChart(coords);
            });
        })

        function createBrush() {
            brush = d3.brush()
                    .on("brush", brushed);
        
            svg.append("g")
                .attr("class", "brush")
                .call(brush)
                .selectAll("rect")
                .attr("height", h);
        }

        function createMap(json) {
            svg.append("defs")
                .append("clipPath")
                .attr("id", "clip")
                .append("rect")
                .attr("width", w)
                .attr("height", h + 20)

            // https://stackoverflow.com/questions/14492284/center-a-map-in-d3-given-a-geojson-object
            var width  = w;
            var height = 500;

            var center = d3.geoCentroid(json)
            mapCenter = center;

            var scale  = 150;
            var offset = [w/2, h/3];

            projection = d3.geoMercator()
                            .center(center)
                            .translate(offset)
                            .scale(scale);

            // create the path
            path = d3.geoPath().projection(projection);

            // using the path determine the bounds of the current map and use 
            // these to determine better values for the scale and translation
            var bounds  = path.bounds(json);
            var hscale  = scale*width  / (bounds[1][0] - bounds[0][0]);
            var vscale  = scale*height / (bounds[1][1] - bounds[0][1]);
            var scale   = (hscale < vscale) ? hscale : vscale;
            var offset  = [width - (bounds[0][0] + bounds[1][0])/2,
                            height - (bounds[0][1] + bounds[1][1])/2];

            mapOffset = offset;

            // new projection
            projection = d3.geoMercator()
                            .center(center)
                            .scale(scale)
                            .translate(offset);

            path = path.projection(projection);

            mapScale = scale;
            var zoomScale = scale * zoomMultiplier;

            //Bind data and create one path per GeoJSON 
            svg.selectAll("path")
                    .data(json.features)
                    .enter()
                    .append("path")
                    .attr("class", "map")
                    .attr("clip-path", "url(#clip)")
                    .attr("d", path)
                    .on("mouseover", function(d) {
                        d3.select(this)
                            .style("fill", "lightgrey");

                        // Tooltip
                        div.transition()		
                            .duration(200)		
                            .style("opacity", .9);

                        div.html(d.properties.name)	
                            .style("left", (d3.event.pageX) + "px")		
                            .style("top", (d3.event.pageY - 28) + "px");
                    })
                    .on("mouseout", function(e) {
                        d3.select(this)
                            .style("fill", "transparent");

                        div.transition()		
                            .duration(500)		
                            .style("opacity", 0);
                    })
                    .on("click", function(d) {
                        let districtName = d.properties.name;
                        console.log("Clicked " + districtName)
                        
                        projection = d3.geoMercator()
                                        .center(d3.geoCentroid(d))
                                        .scale(zoomScale)
                                        .translate(mapOffset);

                        path = path.projection(projection);

                        // Zoom into map area
                        d3.selectAll("path")
                            .transition()
                            .duration(500)
                            .attr("d", path);

                        // Move circles correspondly
                        updateCirclePositions(zoomMultiplier);

                        // Show reset button
                        d3.select("p.reset")
                            .transition()
                            .duration(500)
                            .style("opacity",1)

                        // Update title label
                        d3.select("text.hourBarTitle")
                            .text(districtName);

                        // Update hour chart with fires from this district
                        var districtData = [];
                        circleData = d3.selectAll("circle").data();
                        circleData.forEach(d => {
                            if (d.district == districtName) {
                                districtData.push(d)
                            }
                        })
                        console.log(districtData)
                        updateBarChartValues(districtData);
                    })
                    .style("z-index", 1000)
                    .style("stroke-width", "1px")
                    .style("stroke", "black")
                    .style("fill", "transparent");
        }

        function resetMap() {
            projection = d3.geoMercator()
                            .center(mapCenter)
                            .scale(mapScale)
                            .translate(mapOffset);

            path = path.projection(projection);

            d3.selectAll("path").transition().duration(500).attr("d", path);

            updateCirclePositions(1);

            // Update title
            d3.select("text.hourBarTitle")
                .text("All districts");

            // Update hourChart with all data
            circleData = d3.selectAll("circle").data();
            updateBarChartValues(circleData);
        }

        var circleRadius = 2;

        function plotIncidents(coords) {
            circles = svg.append("g")
                        .selectAll(".point")
                        .data(coords)
                        .enter()
                        .append("circle")
                        .attr("clip-path", "url(#clip)")
                        .attr("cx", function(d) {
                            return projection([d.lon, d.lat])[0];
                        })
                        .attr("cy", function(d) {
                            return projection([d.lon, d.lat])[1];
                        })
                        .attr("r", circleRadius)
                        .attr("fill", "orange")
                        .attr("class", "non_brushed_circle")
                        .on("mouseover", function(d) {
                            // Tooltip
                            div.transition()		
                                .duration(200)		
                                .style("opacity", .9);

                            div.html("Description: " + d.desc + "</br>" + "Index: " + d.index + "</br>" + "District: " + d.district + "</br>" + "Location: " + d.lon + "," + d.lat)	
                                .style("left", (d3.event.pageX) + "px")		
                                .style("top", (d3.event.pageY - 28) + "px");
                        })
                        .on("mouseout", function(e) {
                            div.transition()		
                                .duration(500)		
                                .style("opacity", 0);
                        })
        }

        function updateCirclePositions(radius) {
            circles.transition()
                    .duration(500)
                    .attr("cx", function(d) {
                        return projection([d.lon, d.lat])[0];
                    })
                    .attr("cy", function(d) {
                        return projection([d.lon, d.lat])[1];
                    })
                    .attr("r", circleRadius*radius);
        }
    
        var yScaleBar, xScaleBar;
        const yPaddingForTitle = 30; // To make room for title

        function createFireByHourBarChart(brushedData) {
            var tempHourData = [];
            for(var i = 0; i < brushedData.length; i++) {
                tempHourData.push(brushedData[i].hour);
            }
            var filteredData = d3.nest()
                                .key(function(d) {
                                    return d;
                                })
                                .entries(tempHourData);

            var ascending = function (a, b) {
                return a.key - b.key
            }

            var sortData = filteredData.sort(ascending);

            yScaleBar = d3.scaleLinear()
                    .domain([0, d3.max(sortData, function(d) {
                        return d.values.length;
                    } )])
                    .rangeRound([hBar,0]);

            xScaleBar = d3.scaleBand()
                        .rangeRound([0,wBar])
                        .padding(0,1)
                        .domain(sortData.map(function(d,i) {
                            return +d.key;
                        }));
            
            //Create X axis
            svgHourBar.append("g")
                .attr("class", "axis-x")
                .attr("transform", "translate(" + margin.left + "," + (hBar+margin.top+yPaddingForTitle) + ")")
                .call(d3.axisBottom(xScaleBar));
            
            //Create Y axis
            svgHourBar.append("g")
                .attr("class", "axis-y")
                .attr("transform", "translate(" + margin.left + "," + (margin.top+yPaddingForTitle) + ")")
                .call(d3.axisLeft(yScaleBar));

            // Title label
            svgHourBar.append("text")
                        .attr("class", "hourBarTitle")
                        .attr("x", 0 + wBar/2 + 20)
                        .attr("y", 10)
                        .attr("dy", "1em")
                        .text("All districts");

            // X-Label
            svgHourBar.append("text")
                    .attr("class", "legendText")
                    .attr("transform",
                            "translate(" + ((wBar/2)+margin.left/2) + "," + 
                                        (hBar+35+margin.top+yPaddingForTitle) + ")")
                    .text("Hour of day");

            // Y-Label
            svgHourBar.append("text")
                .attr("class", "legendText")
                .attr("transform", "rotate(-90)")
                .attr("y", 0)
                .attr("x", 0 - (hBar / 2) - 70 - yPaddingForTitle)
                .attr("dy", "1em")
                .text("# of fire incidents"); 


            bars = svgHourBar.append("g")
                    .selectAll("rect1")
                    .data(sortData)
                    .enter()
                    .append("rect")
                    .attr("class", "selData")
                    .attr("transform", "translate(" + margin.left + ","+ margin.top +")")
                    .attr("x", function(d,i) {
                        return xScaleBar(+d.key);
                    })
                    .attr("y", function(d) {                        
                        return yScaleBar(d.values.length) + yPaddingForTitle;
                    })
                    .attr("width", xScaleBar.bandwidth()-1)
                    .attr("height", function(d){
                        return hBar-yScaleBar(d.values.length);
                    });
        }

        function brushed() {
            if (d3.event.selection != null) {
                // revert circles to initial style
                circles.attr("class", "non_brushed");

                var brush_coords = d3.brushSelection(this);

                // style brushed circles
                circles.filter(function (){

                        var cx = d3.select(this).attr("cx"),
                            cy = d3.select(this).attr("cy");
                        return isBrushed(brush_coords, cx, cy);
                })
                .attr("class", "brushed");

                var d_brushed =  d3.selectAll(".brushed").data();
                if (d_brushed.length > 0) {
                    // clearChart();
                    // createBarChart(d_brushed);
                    updateBarChartValues(d_brushed);
                } else {
                    // clearChart();
                    updateBarChartValues(d_brushed);
                }
            }
        }



        function isBrushed(brush_coords, cx, cy) {
            var x0 = brush_coords[0][0],
                x1 = brush_coords[1][0],
                y0 = brush_coords[0][1],
                y1 = brush_coords[1][1];

            return x0 <= cx && cx <= x1 && y0 <= cy && cy <= y1;
        }



        function updateBarChartValues(newValues) {
            var tempHourData = [];
            for(var i = 0; i < newValues.length; i++) {
                tempHourData.push(newValues[i].hour);
            }
             console.log(newValues)

            var filteredData = d3.nest()
                                .key(function(d) {
                                    return d;
                                })
                                .entries(tempHourData);

            // console.log(filteredData)

            var ascending = function (a, b) {
                return a.key - b.key
            }

            var sortData = filteredData.sort(ascending);

            var data = [];

            for(var i = 0; i < hoursLabels.length; i++) {
                data.push({
                    'hour': "" + (i),
                    'values': []
                })
            }

            // console.log(data)

            sortData.forEach( d => {
                var index = d.key;
                data[index] = d;
            })

            // console.log(sortData)

            sortData = data;

            yScaleBar = d3.scaleLinear()
                    .domain([0, d3.max(sortData, function(d) {
                        return d.values.length;
                    } )])
                    .rangeRound([hBar,0]);

            svgHourBar.selectAll("g.axis-y")
                    .call(d3.axisLeft(yScaleBar));

            svgHourBar.selectAll("rect")
                    .data(sortData)
                    .transition()
                    .duration(250)
                    .ease(d3.easeLinear)
                    .attr("class","selData")
                    .attr("transform","translate(" + margin.left + ","+ margin.top +")")
                    .attr("x",function(d,i) {
                        return xScaleBar(+d.key);
                    })
                    .attr("y",function(d) {                    
                        return yScaleBar(d.values.length) + yPaddingForTitle;
                    })
                    .attr("width",xScaleBar.bandwidth()-1)
                    .attr("height",function(d){
                        return hBar-yScaleBar(d.values.length);
                    })
                    .attr("fill","black");
        }

    </script>  
  </body>
</html>